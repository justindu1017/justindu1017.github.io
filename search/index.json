[{"content":"施工中\u0026hellip;敬請期待~~~~~ ","date":"2021-03-19T00:00:00Z","permalink":"https://justindu1017.github.io/p/js-%E7%9A%84-callback-promise-%E8%88%87-async/await-promise-%E7%AF%87/","title":"JS 的 Callback, Promise 與 Async/Await -- Promise 篇"},{"content":"JS 啥時執行，搞不清? 在我們正式開始這次的議題前，我們先來針對以下的程式碼進行一次簡單的示範\n#JavaScript; for (let i = 0; i \u0026lt; 6; i++) { setTimeout(function TO() { console.log(i); }, 2000); } 上面這串 JS，你認為輸出為何呢\nA. 每兩秒鐘 log 出一個數字\nB. 2 秒鐘後一次 log 出 6 個數字\n對於較沒基礎的朋友來說，有很高的機會選擇 A ，對其他語言來說有可能真的是正確的，但對 JS 來說正確答案應該為 B\n肯定很好奇為甚麼吧? 在這之前，必須先看這部 影片\n原則上看完應該就會了 7、8 成了，以下我們會利用上述影片進行觀念的引導，所以請一定要先看過影片唷~\nCallback Callback 以較直白的解釋就是「Function 去 call Function」\n舉例而言，這邊我創了兩個 Function，並希望輸出順序為:First-\u0026gt;second\nfunction mainFunc() { console.log(\u0026#34;First\u0026#34;); } function callBackFunc() { console.log(\u0026#34;second\u0026#34;); } mainFunc(); callBackFunc(); // 輸出為: // First // second 看起來沒甚麼問題，但假設今天我們這樣改這樣寫\nfunction mainFunc() { console.log(\u0026#34;First\u0026#34;); } function callBackFunc() { console.log(\u0026#34;second\u0026#34;); } callBackFunc(); mainFunc(); // 輸出為: // second // First 看起來不對，但還在預期之內，畢竟我們是先呼叫 callBackFunc()在呼叫 mainFunc()。\n那假如我們假設 mainFunc();會稍微執行一小段時間才會完成呢? 這件事是非常常發生的，可能是因為它內部的程式本來就很大需要執行一小段時間、也可能是因為它是 api，需要透過網路，而這之間就會產生時間的等待，所以我們要特別注意這類型的情況。 這邊我們用一個 setTimeout()來實現等待的情境 這邊先說明一下:setTimeout()在 w3school 的定義如下圖  w3school 針對 setTimeout的定義 \n其中比較常見的用法為:\n// 等待五秒後執行func() setTimeout(/*要做的Func*/, 5000); 所以我們假設我們的 mainFunc()執行到完成需要花費五秒，我們將我們的程式加入 setTimeout 來實現等待\nfunction mainFunc() { setTimeout(function foo() { console.log(\u0026#34;First\u0026#34;); }, 5000); } function callBackFunc() { console.log(\u0026#34;second\u0026#34;); } mainFunc(); callBackFunc(); // 輸出為: // second // 五秒鐘後:First 震驚！明明我先呼叫 mainFunc();，為什麼會先 log 出 second 呢?\n會造成這個結果的原因如下:\n  我們的 mainFunc() 需要經過一較長時間的等待\n  根據上面的影片(假設你有看完的話)，setTimeout 屬於一種 web api\n  根據影片中的解釋，我們可以用較簡單的方式看待 JS 的運作與 event loop 的運作\n也就是下圖  \n影片中有提到我們可以將 JS 的運行分為三個區塊:Stack、webapi(web 端就是瀏覽器、在 node 中是 C++ api)、task queue\\\n 當我們的 JS 在運行時，他會先把一行一行讀下來並把東西放在 stack 中，當前沒有其他東西去 block 住時， 會優先將 Stack 中的東西運行完成並在繼續執行下一行的東西。 當發現屬於 webapi 的物件或是方法時，物件會交由瀏覽器持續執行，並於執行完後將東西或是結果放到我們的將東西或是結果放到我們的 task queue 中。這邊可以先暫時把 webapi 想成一個執行的區域，對新手來說會一個比較好思考的方法 其中 event loop 會觀察 stack 中是否為空且 task queue 是否有東西，若狀況成立就會將 task queue 中的東西推到 stack 中  我們觀察一下我們的 code:前面的兩個 function 為定義，所以沒有輸出。\\\n接著我們遇到了 mainFunc()，而且裡面有一個 setTimeout 屬於 webapi，他暫時被交由 webapis 專屬執行區 執行 5 秒的動作，做完之後會被推到 task queue 中等待 stack 中沒有東西時被 event loop 推上 stack 中執行\\\n當然，我們很快地遇到接下來的 callBackFunc()呼叫，他有一個 console.log，不屬於 webapi 的範圍，因此他就順理成章地先 log 出來了 稍微多等一下 mainFunc 的東西也差不多跑好了，stack 中也沒東西要執行的了，所以會被推上去並且 log 出來\n webapi 的東西必須等到 stack 中是空的並且自身已經執行完畢存在於 task queue，會由 event loop 推上 stack 中執行\n 所以現在我們終於知道位什麼輸出為\nsecond 五秒鐘後:First\n這時你一定會問:那要怎麼修改才能在保留 setTimeout 的特性，並使輸出為: 五秒鐘後 First -\u0026gt; second 呢?\n這時就需要借助到我們這次的主題:Callback Function 回呼函式\nCallback Function 回呼函式 實戰 前面我們有提到:Callback 以較直白的解釋就是「Function 去 call Function」 也就是類似這樣\nfunction a(cb) { //do something  console.log(\u0026#34;this is function a\u0026#34;); cb(); } function b() { console.log(\u0026#34;this is function b\u0026#34;); } a(b); 我們在這邊將我們的 b 在 a 中呼叫，這就是 Callback 的概念 那所以我們在改我們的程式時其實是有很多種改法的，這邊我示範一個我的改法，\nfunction mainFunc(cb) { setTimeout(function TO() { console.log(\u0026#34;First\u0026#34;); cb(); }, 5000); } function callBackFunc() { console.log(\u0026#34;second\u0026#34;); } mainFunc(callBackFunc); // 輸出為: // 五秒鐘後:First // second 我們成功的 print 出我們要的東西了，稍微解釋一下他是怎麼運作的吧 我們一層一層看，首先是兩個 function 的定義，就純粹是在定義所以沒什麼事情發生\n接下來我們看到了 mainFunc(callBackFunc);，他帶入一個參數 callBackFunction，也就是我們定義的一個 function\n在我們執行 mainFunc 時，一進去我們就遇到一個 setTimeout，他帶的 function 是 TO。而且 setTimeout 是一個 webapi，因此我們讓他跑進 webapi 專屬執行區 的地方開始跑五秒\n setTimeout被丟到webapi 專屬執行區執行等待5秒 \n五秒鐘後裡面的 setTimeout 也執行完了，就會把 TO 丟到 task queue 並等待 Stack 中為空  setTimeout執行完畢並將 TO 丟到task queue \n在經過漫長的等待五秒時，Stack 也早就清空了，我們的 TO 也自然而然地被 event loop 推上 stack 中執行\n而在 TO 內我們看到它做了兩件事\n console.log(\u0026ldquo;First\u0026rdquo;); cb()  所以我們就很自然而然地先 log 出 First\n接下來\u0026hellip;注意!這邊就是 callback 的精華!\n我們的 cb()出現了!還記的我說過 callback 其實就是 Function 去 call Function，這邊我們的 function TO 去 call 了 cb()，而 cb 就是，而 cb 就是 callBackFunc()!\n這其實就是 callback 的精華!\n我們這邊的等待五秒，其實就是讓大家(console.log(\u0026ldquo;First\u0026rdquo;)、cb())都一起等五秒在執行。五秒鐘之後再去執行裡面的東西\n上面舉的另一個例子也可以這樣改寫\nfunction mainFunc(cb) { console.log(\u0026#34;First\u0026#34;); cb(); } function callBackFunc() { console.log(\u0026#34;second\u0026#34;); } mainFunc(callBackFunc); // 輸出為: // First // second 也就正常輸出了!\ncallback hell 說道 callback，就不得不說著名的 callback hell\ncallback 其實就是 Function 去 call Function，所以下面的範例也是一種 callback\nfunction a() { console.log(\u0026#34;a\u0026#34;); b(); } function b() { console.log(\u0026#34;b\u0026#34;); } a(); 假設我們再加一個 function c，也讓它繼續 callback\nfunction a() { console.log(\u0026#34;a\u0026#34;); b(c()); } function b() { console.log(\u0026#34;b\u0026#34;); } function c() { console.log(\u0026#34;c\u0026#34;); } a(); 接著我們再來一個 function d\u0026hellip;然後再來一個 function e\u0026hellip;然後再來一個 function f\u0026hellip; 恭喜你，你成功創造出一個 callback hell 了!\n callback hell 的經典 \nfunction 一直 call function，會導致一個很嚴重的結果，就是過於雜亂不好整理，寫 code 的人痛苦，看 code 的人更痛苦。\n因此我們需要有一個好辦法來避免這種情況的發生，這就是我們下一次要講的 Promise\n偷偷劇透，在接下來的 promise 與 async/await 講完後，我們會進到 python 的爬蟲唷~(雖然我也不知道要等多久就是了 QQ\n另外，如果有想要一起討論的或是我有說不好的地方，歡迎在下方留言區或是寄信來一起討論唷~~~ 參考資料:\nhttps://www.w3schools.com/jsref/met_win_settimeout.asp https://www.programiz.com/javascript/examples/pass-parameter-setTimeout https://matthung0807.blogspot.com/2019/05/javascript-callback-callback-function.html https://developer.mozilla.org/zh-TW/docs/Glossary/Callback_function https://www.youtube.com/watch?v=8aGhZQkoFbQ\u0026amp;ab_channel=JSConf https://blog.risingstack.com/node-js-async-best-practices-avoiding-callback-hell-node-js-at-scale/ https://medium.com/@quyetvv/async-flow-from-callback-hell-to-promise-to-async-await-2da3ecfff997\n","date":"2021-03-02T00:00:00Z","permalink":"https://justindu1017.github.io/p/js-%E7%9A%84-callback-promise-%E8%88%87-async/await-callback-%E7%AF%87/","title":"JS 的 Callback, Promise 與 Async/Await -- Callback 篇"},{"content":"哈囉，感謝你進入這個網站 關於我，可以先從 這裡 進行簡單的認識\n在這個網站中，我會定時(偶爾拖更)在這邊發表我最近學到的東西，用簡單易懂的方式進行講解、盡量讓所有人都能懂 這個小網站是用 Hugo 配合 github page 架設的，搭配由 Jimmy Cai 所設計的 Stack 主題\n其中，特別感謝周家豪學長、洪立恩前輩、陳宇震學長教會我這麼多東西，也促成了這個網站的誕生\n還有我的女朋友，一直在背後支持著我\n在這裡，我會觸及到以下的領域 : nodejs, Vue, React, React-Native, Raspberry Pi, python, Verilog, Ubuntu, Unity, LineBot, php, Laravel\u0026hellip;等 偶爾也會穿插一些非程式的專欄 當然，我會慢慢更新，畢竟我現在也還在邊學習。如果有特別想聽的部分的話，也可以連絡我讓我知道，或許就會做特別的學習和認識並解說呢~~~\n現在，就讓我們開始吧!\n","date":"2021-02-24T00:00:00Z","permalink":"https://justindu1017.github.io/p/%E9%97%9C%E6%96%BC%E9%80%99%E5%80%8B%E7%B6%B2%E7%AB%99/","title":"關於這個網站"}]